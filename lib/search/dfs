int dfs(int cur, int a, int b, int c) {
    if(cur == N) {
        if(min({a, b, c}) > 0)
            return abs(A - a) + abs(B - b) + abs(C - c) - 30;
        else
            return INF;
    }
    int a1 = dfs(cur + 1, a, b, c);
    int a2 = dfs(cur + 1, a + l[cur], b, c) + 10;
    int a3 = dfs(cur + 1, a, b + l[cur], c) + 10;
    int a4 = dfs(cur + 1, a, b, c + l[cur]) + 10;
    return min({a1, a2, a3, a4});
}

//二部グラフ判定
bool bpdfs(ll v, ll c) {
    color[v] = c;
    FOREACH(next, g[v]) {
        if(color[next] == c)
            return false;
        else if(color[next] == 0 && !bpdfs(next, -c))
            return false;
    }
    return true;
}

// false<->true
void dfs(ll depth, ll now, ll cost) {
    if(depth == R) {
        ans = min(cost, ans);
        return;
    }
    REP(i, R) if(!went[i]) {
        went[i] = true;
        if(now == -1)
            dfs(depth + 1, i, 0);
        else
            dfs(depth + 1, i, cost + d[r[now]][r[i]]);
        went[i] = false;
    }
}